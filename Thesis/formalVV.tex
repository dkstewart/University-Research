\subsection{Formal Validation and Verification}
Formal validation and verification is a proof-based methodology used to assess the correctness of requirements, system design, and implementation. In the past, this has been performed through manual means, but with the advancement in automated theorem proving and other formal methods, automated formal analyses not only guarantees a higher degree of confidence, but also reduces the time (and thus cost) of carrying out the proofs of correctness. Techniques used in formal validation and verification include automated theorem proving, model checking, and abstract interpretation. 

\subsubsection{Formal Specification}
Formal specification process translates the informal system requirements into a mathematical logic to determine if the system design is correct~\cite{hinchey2012industrial}. This process guarantees an unambiguous description of the requirements which is not possible when using an informal natural language. This formal definition of system requirements includes the system design and its expected behavior as well as the assumptions on environment. A design or implementation can never be considered correct in isolation; it is only correct with respect to the specifications. The expected behavior, system design, and environmental assumptions change and are refined as the system goes through the various stages of development. 

\subsubsection{Formal Verification} 
Formal verification is the use of proof methods to show that given the environmental assumptions stated in the formal specification, the formal design of the system meets the requirements. The problem can be reduced to that of property checking: given a program $P$ and a specific property, does the program satisfy the given property~\cite{fitting2012first}. This is an undecidable problem because a program can be represented as an infinite state space. The problem is that of finding a finite set of predicates that support the specified property over an infinite state space. This is an undecidable problem; any algorithm searching for a solution to this problem may not terminate~\cite{clarke2018model}. The approaches used to provide these proofs are usually deductive methods or an exhaustive exploration of the model known as model checking. 

Model checking was introduced in the early 1980's and consists of exploring the states and transitions of a model~\cite{clarke1981design,queille1982specification}. By representing the system abstractly, the infinite state space is reduced to a finite model. This addresses the undecidability factor~\cite{d2008survey}. The proofs are generated over an abstract mathematical model of the system, such as finite state machines, labeled transition systems, or timed automata. It takes as input a model of a system and the properties written in propositional temporal logic, then explores the entire state space of the system to determine if the model violates the properties~\cite{clarke2018model,fraser2009testing}. In recent years, model checking takes advantage of abstraction techniques specific to a domain to consider multiple states or transitions in a single operation; this lessens computation time considerably~\cite{d2008survey}. Nevertheless, the biggest limiting factor of model checking is scalability and much of the recent research in this area attempts to address this problem~\cite{clarke2018model}.

Deductive methods of verification consists of generating proof obligations from the specifications of the system and using these obligations in a theorem prover setting. Automated theorem provers have the main objective to show that some statement (conjecture) is a logical consequence of other statements (the axioms and hypotheses). The rules of inference are given as are the set of axioms and hypotheses~\cite{d2008survey,fitting2012first}. Deductive methods of verification include automated theorem provers (e.g., Coq~\cite{coq}, Isabelle~\cite{isabelle}) and satisfiability modulo theories (e.g., SMTInterpol~\cite{smtInterpol}, Z3~\cite{z3}, Yices~\cite{yices}). 


