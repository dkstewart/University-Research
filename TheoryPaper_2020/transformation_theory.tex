\subsection{Transformation of All-MIVCs into Minimal Cut Sets}
\label{sec:transformation}
%The IVCs
All Minimal Inductive Validity Cores are collected by use of the All-MIVCs algorithm~\cite{Ghassabani2017EfficientGO}. These are all of the Minimal Unsatisfiable Subsets (MUSs) which can be used as input to the Minimal Hitting Set algorithm~\cite{murakami2013efficient,gainer2017minimal} in order to collect all Minimal Correction Sets (MCSs). The MCSs are then transformed into Minimal Cut Sets according to the following theoretical results. 

The definition of the constraint system follows Definition 1 in Section~\ref{sec:definitions}.

\begin{theorem}  The MinCutSet can be generated by the transformation of the Minimal Correction Set (MCS).

\begin{proof}  All $MCS$s are of the form $MCS = G \cup \overline{F}$ where $G$ consists of contracts in the system and $\overline{F}$ consists of faults constrained to false for constraint system $C$. 

\textbf{Case 1}: $G = \emptyset$\\
In the leaf level of the system, only constrained faults are contained in $MCS$. According to the defintion of an $MCS$, upon removing the constraints from $C$ of the elements contained in the $MCS$, the constraint system is satisfiable. Furthermore, the $MCS$ is the minimal such set. Thus, the constraint system with the \textit{active} faults from $MCS$ will cause the \textit{negation} of the safety property to be satisfied. The set of unconstrained faults found in the $MCS$ is the defintion of a minimal cut set. 

\textbf{Case 2}: $G \neq \emptyset$\\
Let $MCS = \{\lnot f_1,...,\lnot f_n,g_1,...,g_m\}$ where $f_j \in F$ and $g_k \in G$ and $\lnot f$ is a fault activation literal $f$ constrained to \textit{false}. 
For all $g_i \in MCS$, we know that the validity of $g_k$ is required in the proof of the top level property $P$ due to its generation through the All-MIVCs algorithm. For $g_1 \in MCS$, there exists a set containing all minimal cut sets of $g_1$. Call this $Cut(g_1) = \{F_{1i} \subseteq F | F_{1i}$ is a min cut set for $g_1, i = 1,...,p_1\}$. 

Replace $g_1$ with $F_{1i}$ for all $i = 1,...,p_1$. This produces $p_1$ new MCSs of the form:
\begin{center}
$\{f_1,...,f_n,F_{11},...,g_m\}$\\
$\{f_1,...,f_n,F_{12},...,g_m\}$\\
$\vdots$\\
$\{f_1,...,f_n,F_{1p_1},...,g_m\}$\\
\end{center}

Perform this replacement for all $g_k \in MCS$, $k=1,...,m$. %This produces at most $|p_1| \times \hdots \times |p_m|$ MCSs containing only faults. 

Let $I_\alpha$ be one of the sets generated by full replacement of all contracts in some $MCS_\alpha$ with their respective minimal cut set and all fault activation literals constrainted to \textit{true}.\\

\textit{Claim: $I_\alpha$ is a minimal cut set for safety property $P$}\\
By the definition of $MCS_\alpha$, $C\setminus MCS_\alpha$ is SAT. Thus the fault activation literals in $MCS_\alpha$ are \textit{true} and the contracts in $MCS_\alpha$ are violated. This combination will cause violation of the safety property (i.e., the constraint system $C\setminus MCS_\alpha$ is SAT). 

The generation of $I_\alpha$ consists of replacing all contracts in $MCS_\alpha$ by their respective minimal cut sets and unconstraining all fault activation literals in $MCS_\alpha$. These unconstrained faults cause the violation of all contracts in $MCS_\alpha$. Hence together, the violation of $P$ since $C\setminus MCS_\alpha$ is SAT. Therefore $I_\alpha$ is a cut set for $P$.\\

Minimality follows from the defintion of $MCS$: \\

Assume that $I_\beta \subset I_\alpha$. Then there is at least one $f \in I_\alpha$ where $f \not \in I_\beta$. Let $\lnot f$ be the fault activation literal $f$ constrained to \textit{false}. \\

If $ \lnot f \in MCS_\alpha$ and $f \not \in I_\beta$, then by removing all constraints of the fault literals in $I_\beta$ from $C$ ($C \setminus I_\beta$), we see that the resulting constraint system is UNSAT by the minimality of $MCS_\alpha$. Therefore $I_\beta$ is not a cut set for $P$.\\

If $f \in MinCut(g)$ where $MinCut(g)$ is a minimal cut set for some $g \in MCS_\alpha$, then $C \setminus I_\beta$ will not remove constraints for all of the elements in $MinCut(g)$ and therefore $g$ remains unviolated, i.e., the constraint that $g$ is \textit{true} is not removed. Thus $C \setminus I_\beta$ will not remove constraints for all of the elements in $MCS_\alpha$ which means $C \setminus I_\beta$ is UNSAT. Therefore $I_\beta$ is not a cut set for $P$.

\end{proof}
\end{theorem}

The generation of MIVCs traverses the program in a top down fashion. The transformation of MIVCs to MinCutSets traverses this tree in a bottom up fashion if and only if All-MIVCs have been generated. It is a requirement of the minimal hitting set algorithm that \textit{all} MUSs are used to find the MCSs~\cite{liffiton2016fast,gainer2017minimal,murakami2013efficient}. Thus, once All-MIVCs have been found and the minimal hitting set algorithm has completed, %our 
the MinCutSets Generation algorithm can begin. 

%Initially, we begin with a list of MCSs for each layer. As mentioned previously, at the leaf layer this set only contains constrained faults, but at intermediate layers it is possible for the MCSs to contain a mixture of both constrained inactive faults and valid contracts. When this is the case, a replacement must be made between the contracts and the faults in the model that can cause their violation. Once this replacement begins, this set is no longer an MCS nor is it yet a MinCutSet. We call this set $I$ for \textit{Intermediate Set} in the following algorithm. 

%Initially, we begin
The MinCutSets Generation Algorithm begins with a list of $MCSs$ specific to a top level property. These $MCSs$ may contain a mixture of fault activation literals constrained to \textit{false} and %\textit{true} subcomponent contracts.
and subcomponent contracts constrained to \textit{true}. We remove all constraints from each $MCS$ and call the resulting sets $I$, for \textit{Intermediate} set. Replacement of subcomponent contracts with their respective minimal cut sets can then proceed. For each of those contracts in $I$, we check to see if we have previously obtained a $MinCutSet$ for that contract. If so, replacement is performed. If not, we recursively call this algorithm to obtain the list of all %$MCSs$ 
MinCutSets associated with this subcomponent contract. At a certain point, there will be no more contracts in the set $I$ in which case we have a minimal cut set for the current property. When this set is obtained, we store it in a lookup table keyed by the given property that this $I$ is associated with. 

%Initially, we begin with a list of MCSs for each layers contracts. At the leaf layer, the MCSs only contain constrained to inactive faults, and we remove the constraints to obtain MinCutSet for each component contract at the leaf layer. At the intermediate layers, the MCSs can contain a mixture of constrained inactive faults and valid component contracts. We first remove the constraints on them to obtain an \textit{Intermediate Set}, $I$, that contains active faults and invalid subcomponent contracts, and replace each invalid subcomponent contract with the MinCutSet obtained for that contract from the layer below. We call this intermediate set $I$ in the following algorithm and $List(I)$ is the set of all $MCSs$ for a component contract at the start of the algorithm and all intermediate sets once replacement begins. At the end of the algorithm the minimal cut sets for the top level property are generated.

Notes regarding the following algorithm: at the onset, the current property $P$ is a top level property. Each of the properties has a list of associated $MCSs$. When the algorithm states that constraints on these elements are removed, more specifically the fault activation literals in $MCS$ are constrained to \textit{true} and the component contracts are constrained to \textit{false}. $List(I)$ is the collection of all $MCSs$ with all constraints removed. Assuming All-MIVCs have been found and the minimal hitting set algorithm has terminated, giving us a list of $MCSs$ for each property in the system. 


\begin{algorithm}[h]
\SetKwFunction{FMain}{replace}
 \SetKwProg{Fn}{Function}{:}{}

	\Fn{\FMain{$P$}}{
		$List(I)$:= $List(MCS)$ for $P$ with all constraints removed \;
		\For{all $I \in List(I)$}{
			\eIf{there exists constrained contracts $g \in I$}{
				\For{all constrained contracts $g \in I$}{
					\eIf{there exists $MinCutSets$ for $g$ in lookup table}{
						\For{all $minCut(g)$}{
							$I_{repl} = I$ \;
							$I_{repl} :=$ replace constrained $g$ with $minCut(g)$ \;
							add $I_{repl}$ to $List(I)$ \;
						} %end for all cut sets of g
					}{
						replace($g$) \;
					} % end else if no cut sets in lookup table
				} % end for all constrained contracts in I
			}{
				add $I$ as $minCut(g)$ for $P$ \;
			} %end else if there exists contracts in I
		}%end for all I in list(I)
	}
%	\caption{Minimal Cut Set Generation Algorithm}
	\caption{MinCutSets Generation Algorithm}
	\label{alg:generation_alg}
\end{algorithm}

The number of replacements $R$ that are made in this algorithm are constrained by the number of minimal cut sets there are 
for all $\alpha$ contracts within the set \textit{I}. %$MCS$. 
We call the set of all minimal cut sets for a contract $g$: $Cut(g)$. The following formula defines an upper bound on the number of replacements. The validity of this statement follows directly from the general multiplicative combinatorial principle. Therefore, the number of replacements $R$ is bounded by the following formula where $g_1$ is the first contract being processed in the set \textit{I}.

$R \leq |Cut(g_1)| +  {\displaystyle \sum_{i=1}^{\alpha} }({\displaystyle \prod_{j=1}^{i} |Cut(g_j)|})$\\ 

It is also important to note that the cardinality of $List(I)$ is bounded, i.e. the algorithm terminates. Every new $I$ that is generated through some replacement of a contract with its minimal cut set is added to $List(I)$ in order to continue the replacement process for all contracts in $I$. Thus, the same bound for the number of replacements exists for the size of $List(I)$. Since no infinite sets (either MIVCs or MCSs) are generated by the All-MIVC or minimal hitting set algorithms, all sets are finite.

The reason for this upper bound is that for a contract $g_1$ in $MCS$, we make $|Cut(g_1)|$ replacements and add the resulting lists to $List(I)$. Then we move to the next contract $g_2$ in $I$. We must additionally make $|Cut(g_1)| \times |Cut(g_2)|$ replacements and add all of these resulting lists to $List(I)$, and so on throughout all contracts. Through the use of basic combinatorial principles, we end with the above formula for the upper bound on the number of replacements. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The results from this algorithm are the minimal cut sets for the top level properties. These are presented to the user as described in Section~\ref{sec:fault_analysis_2}.

The MinCutSets are filtered during this process based on the fault hypothesis given. Algorithm~\ref{alg:generation_alg} is the general approach, but this changes slightly depending on which form of analysis is being performed. These differences are outlined in the following subsections.


































