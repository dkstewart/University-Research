\section{Introduction}
\label{sec:intro}

Risk and safety analyses are important activities used to ensure that critical systems operate in an expected way. From nuclear power plants and airplanes to heart monitors and automobiles, critical systems are vitally important in our society. The systems are required to not only operate safely under nominal (normal) conditions, but also under conditions when faults are present in the system. Guaranteeing that system safety properties hold in the presence of faults is an important aspect of critical systems development and falls under the realm of safety analysis. Safety analysis produces various safety related artifacts that are often used during the development process of critical systems~\cite{SAE:ARP4761,SAE:ARP4754A}. Many of these safety artifacts require the generation of \textit{Minimal Cut Sets} (MinCutSets), the minimal sets of faults that cause the violation of a system safety property. Since the introduction of MinCutSets in the field of safety analysis~\cite{vesely1981fault}, much research has been performed to address the generation of these sets~\cite{fta:survey,rauzy1993new,historyFTA,Bozzano:2010:DSA:1951720,rausand2003system}. One of the challenges with minimal cut set generation is is scaling to industrial-sized systems. As the system gets larger, more minimal cut sets are possible with increasing cardinality. In recent years, the capabilities of model checking have been leveraged to address this problem.~\cite{bieber2002combination,schafer2003combining,fta:survey,contractBasedDesign,symbFTA,DBLP:conf/cav/BozzanoCPJKPRT15}. 

Model checking of complex hardware and software models can be challenging in terms of scalability; one way to address this problem is to take advantage of the architecture of the system model through a \textit{compositional} approach~\cite{anderson1996model, clarke1989compositional,mcmillan1999verification}. Compositional model checking reduces the verification of a large system into multiple smaller verification problems; a model checker then performs the verification per layer of the system hierarchy. 

Recently, Ghassabani et al. developed an algorithm that traces a safety property to a minimal set of model elements necessary for proof; this is called the \textit{all minimal inductive validity core} algorithm (\aivcalg)~\cite{GhassabaniGW16,Ghassabani2017EfficientGO,bendik2018online}. 

Inductive validity cores produce the minimal set of model elements necessary to prove a property. Each set contains the \emph{behavioral contracts} -- the requirement specifications for components -- of the model used in a proof. When the \aivcalg algorithm is run, this gives the minimal set of contracts required for proof of a safety property. If all of these sets are obtained, we have insight into not only what is necessary for the verification of the property, but we can also find what combination of contracts, if \emph{violated}, will provide a state of the system which makes the safety property unprovable. 

Safety analysts are often concerned with faults in the system, i.e., when components or subsystems deviate from nominal behavior, and the propagation of errors through the system. To this end, the model elements included in the reasoning process of the \aivcalg algorithm are not only the contracts of the system, but faults as well. This will provide additional insight on how an active fault may violate contracts that directly support the proof of a safety property. 

This paper proposes a new method of MinCutSet generation in a compositional fashion. The main contributions of this research are summarized as follows: 1. We propose a novel method of MinCutSet generation by leveraging Minimal Inductive Validity Cores (MIVCs). % the minimal sets of model elements necessary to prove a safety property. 
2. We provide proof of the soundness of this method. 3. We discuss the implementation of the algorithm for compositional cut set generation.

The organization of the paper is as follows. Section 2 provides formal definitions and background, Section 3 provides a running example, Section 4 outlines the formal proofs and algorithms used in this approach. The implementation of the algorithms is discussed in Section 5 and related work follows in Section 6. The paper ends with a conclusion and discussion of related work.
